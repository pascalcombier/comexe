/*----------------------------------------------------------------------------*
 * PROJECT  ComEXE                                                            *
 * FILENAME lua-libminizip.c                                                  *
 * CONTENT  Raw Lua bindings for minizip to handle ZIP files                  *
 *----------------------------------------------------------------------------*
 * Copyright (c) 2020-2026 Pascal COMBIER                                     *
 * This source code is licensed under the BSD 2-clause license found in the   *
 * LICENSE file in the root directory of this source tree.                    *
 *----------------------------------------------------------------------------*/

/*============================================================================*/
/* MAKEHEADERS PUBLIC INTERFACE                                               */
/*============================================================================*/

#if MKH_INTERFACE

/*---------*/
/* HEADERS */
/*---------*/

/* The external luaopen_libminizip will be generated by makeheaders, but it rely
 * on the type lua_State */
#include <lua.h>

#endif

/*============================================================================*/
/* IMPLEMENTATION HEADERS                                                     */
/*============================================================================*/

#include <stdint.h>  /* uint8_t  */
#include <string.h>  /* memset   */
#include <lauxlib.h> /* luaL_Reg */

/* MiniZip headers */
#include <zip.h>
#include <unzip.h>

#include "comexe.h" /* PLAT_SafeAlloc0 */

/*============================================================================*/
/* ZIP WRITE OPERATIONS                                                       */
/*============================================================================*/

/* Opens a ZIP archive for writing */
static int MZ_ZipOpen (lua_State *LuaState)
{
  const char *Filename = luaL_checkstring(LuaState, 1);
  int         Mode     = luaL_checkinteger(LuaState, 2);
  zipFile     ZipFile  = zipOpen64(Filename, Mode);

  if (ZipFile == NULL)
  {
    lua_pushnil(LuaState);
    lua_pushfstring(LuaState,
                    "Failed to open zip file [%s] (mode %d)",
                    Filename,
                    Mode);
  }
  else
  {
    lua_pushlightuserdata(LuaState, ZipFile);
    lua_pushnil(LuaState);
  }

  return 2; /* Number of values returned on the stack */
}

/* Opens a new file in the ZIP archive for writing */
static int MZ_ZipOpenNewFileInZip (lua_State *LuaState)
{
  zipFile       ZipFile  = lua_touserdata(LuaState, 1);
  const char   *Filename = luaL_checkstring(LuaState, 2);
  int           Method   = luaL_checkinteger(LuaState, 3);
  int           Level    = luaL_checkinteger(LuaState, 4);
  zip_fileinfo  FileInfo;
  int           Result;

  /* Initialize zip_fileinfo with minimal data */
  memset(&FileInfo, 0, sizeof(FileInfo));

  Result = zipOpenNewFileInZip(ZipFile,   /* Zip File               */
                               Filename,  /* Filename               */
                               &FileInfo, /* File info              */
                               NULL,      /* extrafield_local       */
                               0,         /* size_extrafield_local  */
                               NULL,      /* extrafield_global      */
                               0,         /* size_extrafield_global */
                               NULL,      /* Comment                */
                               Method,    /* Compression method     */
                               Level);    /* Compression level      */

  lua_pushinteger(LuaState, Result);

  return 1; /* Number of values returned on the stack */
}

/* Writes data to the currently open file in the ZIP archive */
static int MZ_ZipWriteData (lua_State *LuaState)
{
  zipFile     ZipFile = lua_touserdata(LuaState, 1);
  size_t      Length;
  const char *Buffer  = luaL_checklstring(LuaState, 2, &Length);
  int         Result  = zipWriteInFileInZip(ZipFile, Buffer, (unsigned int)Length);

  lua_pushinteger(LuaState, Result);

  return 1; /* Number of values returned on the stack */
}

/* Closes the currently open file in the ZIP archive */
static int MZ_ZipCloseFile (lua_State *LuaState)
{
  zipFile ZipFile = lua_touserdata(LuaState, 1);
  int     Result  = zipCloseFileInZip(ZipFile);

  lua_pushinteger(LuaState, Result);

  return 1; /* Number of values returned on the stack */
}

/* Closes the ZIP archive */
static int MZ_ZipClose (lua_State *LuaState)
{
  zipFile     ZipFile = lua_touserdata(LuaState, 1);
  const char *Comment = luaL_optstring(LuaState, 2, NULL);
  int         Result  = zipClose(ZipFile, Comment);

  lua_pushinteger(LuaState, Result);

  return 1; /* Number of values returned on the stack */
}

/*============================================================================*/
/* ZIP READ OPERATIONS                                                        */
/*============================================================================*/

/* Opens a ZIP archive for reading */
static int MZ_UnzipOpen (lua_State *LuaState)
{
  const char *Filename = luaL_checkstring(LuaState, 1);
  unzFile     UnzFile  = unzOpen64(Filename);

  if (UnzFile == NULL)
  {
    lua_pushnil(LuaState);
    lua_pushfstring(LuaState,
                    "Failed to open zip file [%s] for reading",
                    Filename);
  }
  else
  {
    lua_pushlightuserdata(LuaState, UnzFile);
    lua_pushnil(LuaState);
  }

  return 2; /* Number of values returned on the stack */
}

/* Positions the ZIP reader at the first file in the archive */
static int MZ_UnzipGoToFirstFile (lua_State *LuaState)
{
  unzFile UnzFile = lua_touserdata(LuaState, 1);
  int     Result  = unzGoToFirstFile(UnzFile);

  lua_pushinteger(LuaState, Result);
  
  return 1; /* Number of values returned on the stack */
}

/* Positions the ZIP reader at the next file in the archive */
static int MZ_UnzipGoToNextFile (lua_State *LuaState)
{
  unzFile UnzFile = lua_touserdata(LuaState, 1);
  int     Result  = unzGoToNextFile(UnzFile);

  lua_pushinteger(LuaState, Result);
  
  return 1; /* Number of values returned on the stack */
}

/* Gets information about the current file */
static int MZ_UnzipGetCurrentFileInfo (lua_State *LuaState)
{
  unzFile           UnzFile = lua_touserdata(LuaState, 1);
  unz_file_info64   FileInfo;
  char              Filename[256];
  int               Result;

  Result = unzGetCurrentFileInfo64(
    UnzFile,          /* Handle to open ZIP file        */
    &FileInfo,        /* Structure to receive file info */
    Filename,         /* Buffer for filename            */
    sizeof(Filename), /* Size of filename buffer        */
    NULL,             /* Extra field buffer             */
    0,                /* Size of extra field buffer     */
    NULL,             /* Comment buffer                 */
    0);               /* Size of comment buffer         */
  
  if (Result == UNZ_OK)
  {
    lua_createtable(LuaState, 0, 8);
    lua_pushstring(LuaState, Filename);
    lua_setfield(LuaState, -2, "filename");
    lua_pushinteger(LuaState, (lua_Integer)FileInfo.uncompressed_size);
    lua_setfield(LuaState, -2, "uncompressed_size");
    lua_pushinteger(LuaState, (lua_Integer)FileInfo.compressed_size);
    lua_setfield(LuaState, -2, "compressed_size");
    lua_pushinteger(LuaState, FileInfo.compression_method);
    lua_setfield(LuaState, -2, "compression_method");
    lua_pushinteger(LuaState, FileInfo.crc);
    lua_setfield(LuaState, -2, "crc");
    lua_pushinteger(LuaState, FileInfo.dosDate);
    lua_setfield(LuaState, -2, "dos_date");
    lua_pushinteger(LuaState, FileInfo.external_fa);
    lua_setfield(LuaState, -2, "external_fa");
    lua_pushinteger(LuaState, FileInfo.internal_fa);
    lua_setfield(LuaState, -2, "internal_fa");
    lua_pushnil(LuaState);
  }
  else
  {
    lua_pushnil(LuaState);
    lua_pushstring(LuaState, "Failed to get current file info");
  }

  return 2; /* Number of values returned on the stack */
}

/* Opens the current file in the ZIP archive for reading */
static int MZ_UnzipOpenCurrentFile (lua_State *LuaState)
{
  unzFile UnzFile = lua_touserdata(LuaState, 1);
  int     Result  = unzOpenCurrentFile(UnzFile);

  lua_pushinteger(LuaState, Result);

  return 1; /* Number of values returned on the stack */
}

/**
 * Low-level function, weird signature: take a temp C buffer in parameter
 * And in the same time: return a Lua string
 * Allow to reuse buffers unlike to MZ_UnzipReadCurrentFileString
 * 
 * Reads data from the currently open file in the ZIP archive
 */
static int MZ_UnzipReadCurrentFile (lua_State *LuaState)
{
  unzFile UnzFile     = lua_touserdata(LuaState, 1);
  int     BytesToRead = luaL_checkinteger(LuaState, 2);
  char   *Data        = lua_touserdata(LuaState, 3);
  int     BufferSize  = luaL_checkinteger(LuaState, 4);
  int     ReadSize;
  int     Result;

  /* Ensure we don't read more than the buffer can hold */
  if (BytesToRead < BufferSize)
  {
    ReadSize = BytesToRead;
  }
  else
  {
    ReadSize = BufferSize;
  }

  Result = unzReadCurrentFile(UnzFile, Data, ReadSize);

  if (Result < 0)
  {
    lua_pushnil(LuaState);
    lua_pushstring(LuaState, "Failed to read current file");
  }
  else if (Result == 0)
  {
    lua_pushstring(LuaState, ""); /* EOF */
    lua_pushnil(LuaState);
  }
  else
  {
    lua_pushlstring(LuaState, Data, Result);
    lua_pushnil(LuaState);
  }

  return 2; /* Number of values returned on the stack */
}

/**
 * Convenience function: do its own buffer allocation and free
 * 
 * Reads data from the currently open file in the ZIP archive (high-level version).
 * This function allocates its own buffer and returns the data as a Lua string.
 */
static int MZ_UnzipReadCurrentFileString (lua_State *LuaState)
{
  unzFile UnzFile     = lua_touserdata(LuaState, 1);
  int     BytesToRead = luaL_checkinteger(LuaState, 2);
  char   *Buffer      = PLAT_SafeAlloc0(BytesToRead, sizeof(char));
  int     Result;

  Result = unzReadCurrentFile(UnzFile, Buffer, BytesToRead);

  if (Result < 0)
  {
    lua_pushnil(LuaState);
    lua_pushstring(LuaState, "Failed to read current file");
  }
  else if (Result == 0)
  {
    lua_pushstring(LuaState, ""); /* EOF */
    lua_pushnil(LuaState);
  }
  else
  {
    lua_pushlstring(LuaState, Buffer, Result);
    lua_pushnil(LuaState);
  }

  PLAT_Free(Buffer);

  return 2; /* Number of values returned on the stack */
}

/* Closes the currently open file in the ZIP archive */
static int MZ_UnzipCloseCurrentFile (lua_State *LuaState)
{
  unzFile UnzFile = lua_touserdata(LuaState, 1);
  int     Result  = unzCloseCurrentFile(UnzFile);

  lua_pushinteger(LuaState, Result);

  return 1; /* Number of values returned on the stack */
}

/* Closes the ZIP archive */
static int MZ_UnzipClose (lua_State *LuaState)
{
  unzFile UnzFile = lua_touserdata(LuaState, 1);
  int     Result  = unzClose(UnzFile);

  lua_pushinteger(LuaState, Result);

  return 1; /* Number of values returned on the stack */
}

/*============================================================================*/
/* LIBRARY REGISTRATION                                                       */
/*============================================================================*/

static const struct luaL_Reg MzLibFunctions[] =
{
  /* ZIP write operations */
  { "zip_open",                       MZ_ZipOpen                    },
  { "zip_open_newfile_in_zip",        MZ_ZipOpenNewFileInZip        },
  { "zip_write_data",                 MZ_ZipWriteData               },
  { "zip_close_file",                 MZ_ZipCloseFile               },
  { "zip_close",                      MZ_ZipClose                   },
  /* ZIP read operations */
  { "unzip_open",                     MZ_UnzipOpen                  },
  { "unzip_goto_first_file",          MZ_UnzipGoToFirstFile         },
  { "unzip_goto_next_file",           MZ_UnzipGoToNextFile          },
  { "unzip_get_current_file_info",    MZ_UnzipGetCurrentFileInfo    },
  { "unzip_open_current_file",        MZ_UnzipOpenCurrentFile       },
  { "unzip_read_current_file",        MZ_UnzipReadCurrentFile       },
  { "unzip_read_current_file_string", MZ_UnzipReadCurrentFileString },
  { "unzip_close_current_file",       MZ_UnzipCloseCurrentFile      },
  { "unzip_close",                    MZ_UnzipClose                 }     ,
  /* End of list */
  { NULL, NULL }
};

/*============================================================================*/
/* PUBLIC API                                                                 */
/*============================================================================*/

static void MZ_RegisterConstant (lua_State  *LuaState,
                                 const char *Name, 
                                 int         Value)
{
  lua_pushinteger(LuaState, Value);
  lua_setfield(LuaState, -2, Name);
}

static void MZ_RegisterZipConstants (lua_State *LuaState)
{
  MZ_RegisterConstant(LuaState, "ZIP_OK",            ZIP_OK);
  MZ_RegisterConstant(LuaState, "ZIP_EOF",           ZIP_EOF);
  MZ_RegisterConstant(LuaState, "ZIP_ERRNO",         ZIP_ERRNO);
  MZ_RegisterConstant(LuaState, "ZIP_PARAMERROR",    ZIP_PARAMERROR);
  MZ_RegisterConstant(LuaState, "ZIP_BADZIPFILE",    ZIP_BADZIPFILE);
  MZ_RegisterConstant(LuaState, "ZIP_INTERNALERROR", ZIP_INTERNALERROR);
}

static void MZ_RegisterUnzipConstants (lua_State *LuaState)
{
  MZ_RegisterConstant(LuaState, "UNZ_OK",                  UNZ_OK);
  MZ_RegisterConstant(LuaState, "UNZ_END_OF_LIST_OF_FILE", UNZ_END_OF_LIST_OF_FILE);
  MZ_RegisterConstant(LuaState, "UNZ_ERRNO",               UNZ_ERRNO);
  MZ_RegisterConstant(LuaState, "UNZ_EOF",                 UNZ_EOF);
  MZ_RegisterConstant(LuaState, "UNZ_PARAMERROR",          UNZ_PARAMERROR);
  MZ_RegisterConstant(LuaState, "UNZ_BADZIPFILE",          UNZ_BADZIPFILE);
  MZ_RegisterConstant(LuaState, "UNZ_INTERNALERROR",       UNZ_INTERNALERROR);
  MZ_RegisterConstant(LuaState, "UNZ_CRCERROR",            UNZ_CRCERROR);
}

static void MZ_RegisterAppendConstants (lua_State *LuaState)
{
  MZ_RegisterConstant(LuaState, "APPEND_STATUS_CREATE",      APPEND_STATUS_CREATE);
  MZ_RegisterConstant(LuaState, "APPEND_STATUS_CREATEAFTER", APPEND_STATUS_CREATEAFTER);
  MZ_RegisterConstant(LuaState, "APPEND_STATUS_ADDINZIP",    APPEND_STATUS_ADDINZIP);
}

static void MZ_RegisterCompressionConstants (lua_State *LuaState)
{
  MZ_RegisterConstant(LuaState, "Z_NO_COMPRESSION",      Z_NO_COMPRESSION);
  MZ_RegisterConstant(LuaState, "Z_BEST_SPEED",          Z_BEST_SPEED);
  MZ_RegisterConstant(LuaState, "Z_BEST_COMPRESSION",    Z_BEST_COMPRESSION);
  MZ_RegisterConstant(LuaState, "Z_DEFAULT_COMPRESSION", Z_DEFAULT_COMPRESSION);
  MZ_RegisterConstant(LuaState, "Z_DEFLATED",            Z_DEFLATED);
}

extern int luaopen_libminizip (lua_State *LuaState)
{
  /* Create the table with all functions */
  luaL_newlib(LuaState, MzLibFunctions);
  
  /* Register constants */
  MZ_RegisterZipConstants(LuaState);
  MZ_RegisterUnzipConstants(LuaState);
  MZ_RegisterAppendConstants(LuaState);
  MZ_RegisterCompressionConstants(LuaState);

  return 1; /* Number of values returned on the stack */
}
